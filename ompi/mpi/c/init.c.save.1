/*
 * Copyright (c) 2004-2007 The Trustees of Indiana University and Indiana
 *                         University Research and Technology
 *                         Corporation.  All rights reserved.
 * Copyright (c) 2004-2018 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 * Copyright (c) 2004-2006 High Performance Computing Center Stuttgart,
 *                         University of Stuttgart.  All rights reserved.
 * Copyright (c) 2004-2005 The Regents of the University of California.
 *                         All rights reserved.
 * Copyright (c) 2007-2018 Cisco Systems, Inc.  All rights reserved
 * Copyright (c) 2007-2008 Sun Microsystems, Inc.  All rights reserved.
 * Copyright (c) 2015      Research Organization for Information Science
 *                         and Technology (RIST). All rights reserved.
 * $COPYRIGHT$
 *
 * Additional copyrights may follow
 *
 * $HEADER$
 */

#include "ompi_config.h"

#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <string.h>
#include <sys/queue.h>
#include <sys/time.h>
#include <mysql/mysql.h>

#include "opal/util/show_help.h"
#include "ompi/runtime/ompi_spc.h"
#include "ompi/mpi/c/bindings.h"
#include "ompi/communicator/communicator.h"
#include "ompi/errhandler/errhandler.h"
#include "ompi/constants.h"
#include "ompi/mpi/c/init.h"


#if OMPI_BUILD_MPI_PROFILING
#if OPAL_HAVE_WEAK_SYMBOLS
#pragma weak MPI_Init = PMPI_Init
#endif
#define MPI_Init PMPI_Init
#endif

typedef struct qentry {
    char* type;
    int data;
    time_t start;
    TAILQ_ENTRY(qentry) pointers;
} qentry;


static TAILQ_HEAD(, qentry) head;

void enqueue(char* type, int value, time_t ctime){
    //printf("Current Time: %ld \n", ctime);
    qentry *item = (qentry*)malloc(sizeof(qentry));
    item->data = value;
    item->type = type;
    item->start = ctime;
    TAILQ_INSERT_TAIL(&head, item, pointers);
}

qentry* dequeue(){
    qentry *item;
    item = TAILQ_FIRST(&head);
    TAILQ_REMOVE(&head, item, pointers);
    return item;
}

//Needs to be global!
pthread_t MONITOR_THREAD = NULL;

//Database Information
static MYSQL *conn;
static char *server = "192.168.42.9";
static char *user = "AnnaLena";
static char *password = "annalena";
static char *database = "DataFromMPI";

static const int LIMIT = 100;
static int count = LIMIT;
static char *batchstring = "INSERT INTO MPI_Data(type, value)VALUES";

static void insertData(char **batchstr){
    count = LIMIT;
    char *batch = *batchstr;
    batch[strlen(batch)-1]=';';
    if(mysql_query(conn, batch)){
        fprintf(stderr, "%s\n", mysql_error(conn));
        exit(1);
    }
}

static void collectData(qentry **item, char **batchstr){
    qentry *q = *item;
    char *data=(char*)malloc(sizeof(char)*30);
    sprintf(data, "('%s',%d),", q->type, q->data);
    *batchstr = realloc(*batchstr, strlen(*batchstr)+1 + strlen(data)+1);
    strcat(*batchstr, data);
    free(data);
    count--;
    if(count==0){
	char *batch = *batchstr;
	insertData(&batch);
	*batchstr = realloc(*batchstr, strlen(batchstring)+1);
	strcpy(*batchstr, batchstring);
    }
}

static void* MonitorFunc(void* _arg){
    qentry *item = (qentry*)malloc(sizeof(qentry));
    char *batch=(char*) malloc(strlen(batchstring)+1);
    strcpy(batch, batchstring);
    int finish = 0;
    while(!finish){
        if(TAILQ_EMPTY(&head)){
            sleep(1);
            if(TAILQ_EMPTY(&head)){
                finish = 1; 
            }
        }
        else {
